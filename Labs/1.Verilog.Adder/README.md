# Лабораторная работа 1 "Сумматор"

## Цель

Познакомиться с САПР Vivado и научиться реализовывать в нём схемотехнические модули, с помощью конструкций языка Verilog, а также писать к ним тестовое окружение на примере одноразрядного и многоразрядного сумматора.

## Ход работы

1. Тренинг по созданию проекта в Vivado;
2. Изучение простейших конструкций Verilog;
3. Изучение, реализация и проверка полного однобитного сумматора;
4. Реализация полного четырехбитного сумматора;
5. Реализация 32-битного сумматора.

## Теория

Итогом лабораторной работы будет создание устройства, способного складывать два числа. Но перед тем, как учиться создавать подобное устройство, необходимо немного освоиться в самом процессе складывания чисел.

Давайте начнем с примера, и сложим в столбик какую-нибудь пару чисел, например 42 и 79:

![Сложение в столбик десятичных чисел](../../.github/pic/1.Verilog.Adder/dec_column.png)

2 + 9 = 11	➨ 1 пишем, 1 "в уме".

4 + 7 = 11	➨ +1 "в уме" = 12 — 2 пишем, 1 "в уме".

0 + 0 = 0	➨ +1 "в уме" = 1.

Итого, 121.

Назовём то, что мы звали "1 в уме" переносом разряда.

Теперь, попробуем сделать тоже самое, только в двоичной системе исчисления. К примеру, над числами 3 и 5. Три в двоичной системе записывается как 011, Пять записывается как 101.

![Сложение в столбик двоичных чисел](../../.github/pic/1.Verilog.Adder/bin_column.png)

Поскольку в двоичной системе всего две цифры: 0 и 1, один разряд не может превысить 1. Складывая числа 1 и 1, вы получаете 2, что не умещается в один разряд, поэтому мы пишем 0 и 1 в уме. Это снова перенос разряда. Поскольку в двоичной арифметике разряд называют битом, перенос разряда называют переносом бита, а сам разряд, который перенесли — битом переноса.

### Полный однобитный сумматор

Полный однобитный сумматор — это цифровое устройство с тремя входными сигналами: операндами a, b и входным битом переноса, которое складывает их между собой, возвращая два выходных сигнала: однобитный результат суммы и выходной бит переноса. Что такое входной бит переноса? Давайте вспомним второй этап сложения чисел 42 и 79:

4 + 7 = 11, ➨ **+1 в уме** = 12 — 2 пишем, 1 в уме.

**+1 в уме** — это разряд, перенесённый с предыдущего этапа сложения.

Входной бит переноса — это разряд, перенесённый с предыдущего этапа сложения двоичных чисел. Имея этот сигнал, мы можем складывать многоразрядные двоичные числа путём последовательного соединения нескольких однобитных сумматоров: выходной бит переноса сумматора младшего разряда передастся на входной бит переноса сумматора старшего разряда.

### Реализация одноразрядного сложения

Можно ли как-то описать сложение двух одноразрядных двоичных чисел с помощью логических операций? Давайте посмотрим на таблицу истинности подобной операции

<img src="../../.github/pic/1.Verilog.Adder/tt1.png" alt="Таблица истинности одноразрядного сложения" width="150"/>

<!-- |a|b| |<b>P</b>|<b>S</b>|
|-|-|-|--------|--------|
| | | |        |        |
|0|0| |<b>0</b>|<b>0</b>|
|0|1| |<b>0</b>|<b>1</b>|
|1|0| |<b>0</b>|<b>1</b>|
|1|1| |<b>1</b>|<b>0</b>| -->

*Таблица истинности одноразрядного сложения*

S — это цифра, записываемая непосредственно в столбце сложения под числами a и b. P — это цифра, записываемая левее, которая обычно записывается, если произошел перенос разряда. Как мы видим, перенос разряда происходит только в случае, когда оба числа одновременно равны единице. При этом в этот момент значение S обращается в 0, и результат записывается как 10, что в двоичной системе означает 2. Кроме того, S = 0 и в случае, когда оба операнда одновременно равны нулю. Вы можете заметить, что S = 0 в тех случаях, когда а и b равны, и не равно нулю в противоположном случае. Подобное свойство описывается логической операцией исключающее или:

<img src="../../.github/pic/1.Verilog.Adder/tt2.png" alt="Таблица истинности операции Исключающее ИЛИ (XOR)" width="190"/>

*Таблица истинности операции Исключающее ИЛИ (XOR)*

Для бита переноса всё ещё проще — он описывается операцией логическое И:

<img src="../../.github/pic/1.Verilog.Adder/tt3.png" alt="Таблица истинности операции И" width="160"/>

*Таблица истинности операции И*

Давайте нарисуем цифровую схему, связывающую входные и выходные сигналы с помощью логических элементов, соответствующих ожидаемому поведению:

![Рисунок 1. Цифровая схема устройства, складывающего два операнда с сохранением переноса (полусумматора)](../../.github/pic/1.Verilog.Adder/1_fig-1.png)

*Рисунок 1. Цифровая схема устройства, складывающего два операнда с сохранением переноса (полусумматора)*

Вроде все замечательно, но есть проблема. В описании полного однобитного сумматора сказано, что у него есть три входа, а в наших таблицах истинности и на схеме выше их только два. На самом деле, на каждом этапе сложения в столбик мы всегда складывали три числа: цифру верхнего числа, цифру нижнего числа, и единицу в случае переноса разряда из предыдущего столбца или ноль, в случае отсутствия переноса. Таким образом, таблицы истинности немного усложняются:

<img src="../../.github/pic/1.Verilog.Adder/tt4.png" alt="Таблица истинности сигналов полного однобитного сумматора" width="250"/>

*Таблица истинности сигналов полного однобитного сумматора*

Поскольку теперь у нас есть и входной и выходной биты переноса, для их различия добавлены индексы “in” и “out”.

Как в таком случае описать S? Например, как `a ^ b ^ Pin`, где `^` — операция исключающего ИЛИ. Давайте сравним такую операцию с таблицей истинности. Сперва вспомним, что Исключающее ИЛИ — ассоциативная операция [`(a^b)^c = a^(b^с)`], т.е. нам не важен порядок вычисления. Предположим, что Pin равен нулю. Исключающее ИЛИ с нулем дает второй операнд (`a^0=a`), значит `(a^b)^0 = a^b`. Это соответствует верхней половине таблицы истинности для сигнала S.

Предположим, что Pin равен единице. Исключающее ИЛИ с единицей дает нам отрицание второго операнда (`a^1=!a`), значит `(a^b)^1=!(a^b)`. Это соответствует нижней половине таблицы истинности.

Для выходного бита переноса, всё гораздо проще. Он равен единице, когда хотя бы два из трех операндов равны единице, это значит что необходимо попарно сравнить все операнды, и если найдется хоть одна такая пара, он равен единице. Это утверждение можно записать следующим образом:

`Pout = (a&b) | (a&Pin) | (b&Pin)`, где `&` — логическое И, `|` — логическое ИЛИ.

Цифровая схема устройства с описанным поведением выглядит следующим образом:

![Рисунок 2. Цифровая схема полного однобитного сумматора](../../.github/pic/1.Verilog.Adder/1_fig-2.png)

*Рисунок 2. Цифровая схема полного однобитного сумматора*

## Практика

Реализуем схему в виде модуля, описанного на языке Verilog:

<br>

<details>

  <summary>Прочти меня перед использованием кода из примера.</summary>

  ### В код намеренно вставлены неподдерживаемые символы. Не копируй, одумайся!

  Важной частью изучения языка является практика по написанию кода. Даже если перепечатывая пример, вы не до конца его понимаете, вы запоминаете структуру кода и его конструкции. Вы изучаете этот пример для себя, а не для оценки, так что будьте честны с собой и воспроизведите пример самостоятельно.

<details>

  <summary> — Но мне очень надо.</summary>

  ![im watching you](https://user-images.githubusercontent.com/17159587/187841488-6416fd6d-0768-4944-9d08-30f8086942d2.jpg)

</details>

<details>

  <summary> — Я переписал пример точь-в-точь, а он все равно не работает!</summary>

  Напишите кому-нибудь из [этого списка](../../Other/teachers.md), вам обязательно помогут!

</details>

</details>

```systemverilog
module fulladder(
    input а,
    input b,
    input Ріn,
    output S,
    output Роut
    );

    assign S    = а ^ b ^ Ріn;
    assign Pout = (a & b) | (а & Pin) | (b & Ріn);

endmodule
```

*Листинг 1. Verilog-код модуля fulladder*

По данному коду, САПР сможет реализовать следующую схему:

![Рисунок 3. Цифровая схема полного однобитного сумматора, сгенерированная САПР Vivado](../../.github/pic/1.Verilog.Adder/1_fig-3.png)

*Рисунок 3. Цифровая схема полного однобитного сумматора, сгенерированная САПР Vivado*

Схема похожа на ту, что мы сделали сами, но как проверить, что эта схема не содержит ошибок и делает именно то, что от нее ожидается?

Для этого, необходимо провести моделирование этой схемы. Во время моделирования, на вход схемы подаются входные воздействия. Каждое изменение входных сигналов схемы приводит к каскадному изменению состояния внутренних цепей, которые в итоге меняют выходные сигналы.

Подаваемые на схему входные воздействия формируются верификационным окружением. Верификационное окружение (или тестбенч) — это особый несинтезируемый модуль, который не имеет входных или выходных сигналов. Ему не нужны входные сигналы, поскольку он сам является генератором всех своих внутренних сигналов, и ему не нужны выходные сигналы, поскольку этот модуль ничего не вычисляет, только подает входные воздействия на проверяемый модуль. Внутри тестбенча можно использовать конструкции из несинтезируемого подмножества языка Verilog, в частности программный блок `initial` в котором команды выполняются последовательно, что делает тестбенч чем-то отдаленно похожим на проверяющую программу. Поскольку изменение внутренних цепей происходит с некоторой задержкой относительно изменений входных сигналов, при моделировании есть возможность делать паузы между командами. Это делается с помощью специального символа # после которого стоит количество отсчётов времени симуляции, которое нужно пропустить перед следующей командой.

Перед тем как писать верификационное окружение, необходимо составить план того, как будет проводиться проверка устройства (составить верификационный план).

Как мы хотим проверить устройство, складывающее три однобитных числа? Поскольку устройство настолько простое, что число всех его возможных входных наборов воздействий равно восьми, и  не имеет памяти (т.е. каждый раз, когда модулю подаются на вход одни и те же значения, оно вернет тот же результат), мы можем проверить его работу, перебрав все возможные варианты его работы.

```systemverilog
module testbench();             // <- Не имеет ни входов, ни выходов!

    reg А, В, Р_in;
    wire S, Р_out;

    fulladder DUT(              // <- Подключаем проверяемый модуль
      .a(А),
      .b(В),
      .Pin(P_in),
      .s(S),
      .Pout(P_out)
    );

    initial begin
        А = 0; В = 0; Р_іn = 0; // <- Подаём на входы модуля тестовые
        #5;                     //    воздействия

        А = 1; В = 0; Р_іn = 0;
        #5;                     // <- Делаем паузу в пять отсчётов
                                // времени симуляции перед очередным
        А = 0; В = 1; Р_іn = 0; // изменением входных сигналов
        #5;

        А = 1; В = 1; Р_іn = 0;
        #5;

        А = 0; В = 0; Р_іn = 1;
        #5;

        А = 1; В = 0; Р_іn = 1;
        #5;

        А = 0; В = 1; Р_іn = 1;
        #5;

        А = 1; В = 1; Р_іn = 1;
        #5;
    end

endmodule
```

*Листинг 2. Verilog-код тестбенча для модуля fulladder*

![Рисунок 4. Временная диаграмма, моделирующая работу полного однобитного сумматора](../../.github/pic/1.Verilog.Adder/1_fig-4.png)

*Рисунок 4. Временная диаграмма, моделирующая работу полного однобитного сумматора*

P_out и S объединены вместе, их общую запись в виде десятичного числа вы можете видеть в виде сигнала Result. Можете убедиться, что сумма каждого среза троек, дает правильный результат.

### Полный четырехбитный сумматор

Складывать несколько однобитных чисел не сильно впечатляет, поэтому сейчас мы займемся по-настоящему крутыми вещами — будем складывать пары четырехбитных чисел! Четырехбитные числа — это сила, они позволяют выбрать любое число от 0 до 15, а если сложить два числа с сохранением переноса, то вы получите диапазон результатов вплоть до 31! И вся эта вычислительная мощь будет у вас прямо под рукой — бери и пользуйся!
До этого мы реализовали только сложение одного столбца в столбик, теперь мы хотим реализовать всю операцию сложения в столбик. Как это сделать? Сделать ровно то, что делается при сложении в столбик: сначала сложить младший столбец, получить бит переноса для следующего столбца, сложить следующий и т.д. Давайте посмотрим, как это будет выглядеть на схеме (для простоты, внутренняя логика однобитного сумматора скрыта, но вы должны помнить, что каждый прямоугольник — это та же самая схема, что была представлена выше).

![Рисунок 5. Схема четырехбитного сумматора](../../.github/pic/1.Verilog.Adder/1_fig-5.png)

*Рисунок 5. Схема четырехбитного сумматора*

Фиолетовой линией на схеме показаны провода, соединяющие выходной бит переноса сумматора предыдущего разряда, с входным битом переноса сумматора следующего разряда.
Как же реализовать модуль, состоящий из цепочки других модулей? Половину этой задачи, мы уже сделали, когда писали тестбенч к однобитному сумматору в *Листинге 2* — мы создавали модуль внутри другого модуля и подключали к нему провода. Теперь надо сделать тоже самое, только с чуть большим числом модулей.

```systemverilog
module fulladder4(
    input [3:0] А,
    input [3:0] В,
    input       Ріn,
    output[3:0] S,
    output      Роut
);

    wire [2:0] Р;     // Обратите внимание на то, как подключены
                      // входы и выходы Pin/Pout во всех модулях!
    fulladder a0(
        .a(А[0]),
        .b(В[0]),
        .Pin(Ріn),
        .S(S[0]),
        .Pout(Р[0])
    );

    fulladder a1(
        .a(А[1]),
        .b(В[1]),
        .Pin(Р[0]),
        .S(S[1]),
        .Pout(Р[1])
    );

    fulladder a2(
        .a(А[2]),
        .b(В[2]),
        .Pin(Р[1]),
        .S(S[1]),
        .Pout(Р[2])
    );

    fulladder a3(
        .a(А[3]),
        .b(В[3]),
        .Pin(Р[2]),
        .S(S[3]),
        .Pout(Роut)
    );

    endmodule
```

*Листинг 3. Verilog-код модуля fulladder4*

![Рисунок 6. Схема четырехбитного сумматора, сгенерированная САПР Vivado](../../.github/pic/1.Verilog.Adder/1_fig-6.png)

*Рисунок 6. Схема четырехбитного сумматора, сгенерированная САПР Vivado*

Схема может показаться запутанной, но если присмотреться, вы увидите, как от шин A, B и S отходят линии к каждому из сумматоров, а бит переноса передается от предыдущего сумматора к следующему.

## Задание

Вам необходимо реализовать полный 32-битный сумматор. Соединять вручную 32 однотипных модуля чревато усталостью и ошибками, поэтому для автоматизации подобной задачи существует блок `generate`, в частности — конструкция `generate for`, пример использования которой вы можете увидеть на изображении ниже (так же существуют конструкции `generate if`, `generate case`).

![Листинг 4. Пример использования конструкции generate for](../../.github/pic/1.Verilog.Adder/1_listing-4.png)

*Листинг 4. Пример использования конструкции generate for*

Как вы можете догадаться, в этом примере создано 3 модуля, имена которых оканчиваются на значение итератора, по которому шел цикл, а к самим модулям подключены соответствующие итератору провода из шин. Разумеется, для своих целей вы можете использовать и **i+1** и двойные циклы.

Обратите внимание на `: newgen` стоящий после ключевого слова `begin`. В некоторых САПР, код может не собраться, если у конструкции `generate for` нет названия (лейбла) с помощью подобной записи (двоеточия и названия).

**Обратите внимание**, что данный листинг не является решением вашей задачи, поскольку у вашего сумматора три входа и два выхода, а у сумматора в примере нет бита переноса.

### Порядок выполнения задания

1. Согласно *руководству по созданию проекта в Vivado*:
   1. Создайте проект;
   1. В `Design Sources` проекта создайте `Verilog`-файл `fulladder.v`.
2. Опишите в файле модуль `fulladder`, код которого представлен в *Листинге 1*.
3. В `Design Sources` проекта создайте `Verilog`-файл `fulladder32`.
4. Опишите модуль `fulladder32` с помощью конструкции `generate for` таким образом, чтобы в нем выполнялось поразрядное сложение двух 32-битных чисел с помощью многократного подключения модуля, описанного в файле `fulladder.v`. Пример использования конструкции приведён в *Листинге 4*.
5. Обратите внимание, что входной бит переноса должен подаваться на сумматор, выполняющий сложение нулевого разряда, выходной бит переноса соединяется с выходным битом переноса сумматора, выполняющего сложение 31-го разряда (см. реализацию четырехбитного сумматора в *Листинге 3*).
6. В `Simulation Sources` проекта создайте `Verilog`-файл `testbench`.
7. Опишите в созданном файле модуль `testbench`, код которого представлен в *Листинге 2*.
8. Измените название подключаемого модуля с `fulladder` на `fulladder32`.
9. Измените разрядности подключаемых к модулю `fulladder32` сигналов так, чтобы они соответствовали разрядности его входных и выходных сигналов.
10. Запустите моделирование.
11. Убедитесь, что модуль работает корректно.
12. Попробуйте изменить складываемые во время моделирования числа, изменив присваивание в файле `testbench`, чтобы убедиться, что модуль корректно складывает и многоразрядные числа.
